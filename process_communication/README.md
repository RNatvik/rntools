# Process Communication Package
This package is made for easy setup of cross process communication for python scripts. It is based on a Publisher - 
Subscriber framework. A master node / server is initialized, to which client publishers or subscribers can connect.
This connection uses TCP communication protocol. 

Messages are transmitted as JSON messages and specify a topic, header and data. A Publisher can only publish on a single
topic, while a Subscriber can subscribe to several topics.

## Installation
To use this package, download the repository to some folder. Activate the python 3.8 environment of your choice, 
virtual or otherwise, and use the python terminal to pip install the package.

    pip install ./[your_folder]

The package modules can then be accessed by importing "proccom" 

## Usage
Code examples of how to implement this package can be found in the "examples" folder.

A script running an instance of the Server class must be run before starting Publishers or Subscribers.
This script will be referred to as the "Master Node". This node is responsible for generating handler threads for 
connections made by client Publishers and Subscribers.

When the master node is initialized, Publishers and Subscribers can connect to it. This is done by creating an instance
of the Publisher or Subscriber and calling the connect() method. The client nodes both create a TCP connection to the 
master node when connect() is called. 

The Subscriber creates it's own thread for handling incoming messages and must be supplied with a handler function for 
when a message is received. The Publisher does not create it's own thread and must also be supplied with a user defined 
formatting function.

### Server example
The code below is an example of how to start a Master node / Server. 

    import proccom
    
    # Create server object bound to address 127.0.0.1:5000
    server = proccom.Server('127.0.0.1', 5000)  
    
    # Start the server
    server.start()

Note that Server.start() is a blocking call. A handler can be created for custom stop criteria. The code below shows one
way to implement this. This makes the server run until the user enters "quit" in the terminal, after which the server
will shutdown.

    from threading import Thread
    import proccom
    
    
    def break_cmd(server: proccom.Server):
        stop = False
        while not stop:
            a = input('Server is running, enter "quit" to stop the server\n')
            if a == 'quit':
                stop = True
        server.stop()
    
    
    def main():
        server = proccom.Server('127.0.0.1', 5000)  # Create server object
        break_thread = Thread(target=break_cmd, daemon=False, args=[server])
        break_thread.start()
        server.start()  # Start server
    
    
    if __name__ == '__main__':
        main()


    
### Publisher example

    from proccom import Server, msgs
    

## Message formatting
A message sent across this network will be formatted as:

    {
        "topic": string, 
        "header": {
            "name": string, 
            "sequence": integer, 
            "time": time.time()
        },
        "data": *custom JSON-compatible format*
    }
        
The "topic" and "header" fields are generated by the Publisher.publish(*args) method, where it uses the Publisher's 
identity for the header.name field. The header.sequence is a counter which increments each time the publisher publishes 
a message. The data field is generated by the user defined formatting function (supplied in the Publisher's constructor)
when Publisher.publish(*args) is called. 